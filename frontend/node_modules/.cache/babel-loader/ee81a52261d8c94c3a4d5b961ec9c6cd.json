{"ast":null,"code":"import Render from '../../Render';\nimport { mapAtlas } from '../../../../../Images';\nimport { canvasMapOffset } from '../../../Helpers';\n\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport default class Wild {\n  constructor() {\n    this.render = new Render();\n    this.level = false;\n    this.layer = false;\n    this.currentLevel = false;\n  }\n\n  draw(canvas, map, player) {\n    if (!this.level || this.currentLevel !== player.info.currentLevel) {\n      this.currentLevel = player.info.currentLevel;\n      this.createMap(map);\n    }\n\n    if (map) {\n      let level = map.body;\n\n      for (let x = level.pos.x; x <= level.size.x; x++) {\n        for (let y = level.pos.y; y <= level.size.y; y++) {\n          let offset = canvasMapOffset(player, x, y, canvas);\n          this.render.img(this.level[x][y], offset.x, offset.y, 32, 32, canvas.ctx);\n\n          if (this.layer[x][y]) {\n            this.render.img(this.layer[x][y], offset.x, y * 32 - player.body.pos.y, this.layer[x][y].pos.width, this.layer[x][y].pos.height, canvas.ctx);\n          }\n        }\n      }\n    }\n  }\n\n  createMap(map) {\n    let mapIndex = Math.floor(this.currentLevel / 30);\n    let mapKeys = Object.keys(mapAtlas.terrain);\n\n    if (mapIndex >= mapKeys.length) {\n      mapIndex = mapKeys.length - 1;\n    }\n\n    let floor = mapKeys[mapIndex];\n    let main = mapAtlas.terrain[floor].light.base.main;\n    let specks = mapAtlas.terrain[floor].light.base.specks;\n    let full = mapAtlas.terrain[floor].light.base.hole;\n    let patch = mapAtlas.terrain[floor].light.layer.patch;\n    let bigHole = mapAtlas.terrain[floor].light.layer.bigHole;\n    let smallSpot = mapAtlas.terrain[floor].light.layer.smallSpot; // let tinySpot = mapAtlas.terrain[floor].light.layer.tinySpot;\n\n    let mapChoice = [main, specks, full];\n    let layer = [patch, bigHole, smallSpot];\n    this.level = [];\n    this.layer = [];\n\n    if (map) {\n      let level = map.body;\n\n      for (let x = level.pos.x; x <= level.size.x; x++) {\n        this.level[x] = [];\n        this.layer[x] = [];\n\n        for (let y = level.pos.y; y <= level.size.y; y++) {\n          this.level[x][y] = mapChoice[randomInt(0, 2)];\n          let layerChance = randomInt(0, 100);\n\n          if (layerChance < 3) {\n            this.layer[x][y] = layer[layerChance];\n          } else {\n            this.layer[x][y] = false;\n          }\n        }\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/ericbucheit/Desktop/Projects/idleForestV2/frontend/src/Components/Canvas/Draw/Level/Wild/index.js"],"names":["Render","mapAtlas","canvasMapOffset","randomInt","min","max","Math","floor","random","Wild","constructor","render","level","layer","currentLevel","draw","canvas","map","player","info","createMap","body","x","pos","size","y","offset","img","ctx","width","height","mapIndex","mapKeys","Object","keys","terrain","length","main","light","base","specks","full","hole","patch","bigHole","smallSpot","mapChoice","layerChance"],"mappings":"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","sourcesContent":["import Render from '../../Render'\nimport {mapAtlas} from '../../../../../Images'\nimport {canvasMapOffset} from '../../../Helpers'\n\nfunction randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport default class Wild {\n\tconstructor() {\n\t\tthis.render = new Render()\n        this.level = false;\n        this.layer = false;\n        this.currentLevel = false\n\t}\n\n    draw(canvas, map, player) {\n        if (!this.level || this.currentLevel !== player.info.currentLevel) {\n            this.currentLevel = player.info.currentLevel\n            this.createMap(map)\n        }\n\n        if (map) {\n            let level = map.body;\n            for (let x = level.pos.x; x <= level.size.x; x++) {\n                for (let y = level.pos.y; y <= level.size.y; y++) {\n                    let offset = canvasMapOffset(player, x, y, canvas);\n                    this.render.img(this.level[x][y], offset.x, offset.y, 32,32, canvas.ctx);\n                    if (this.layer[x][y]) {\n                        this.render.img(this.layer[x][y], offset.x, y * 32 - player.body.pos.y, this.layer[x][y].pos.width, this.layer[x][y].pos.height, canvas.ctx)\n                    }\n                }\n            }\n        }\n\n    }\n\n\tcreateMap(map) {\n       \n        let mapIndex = Math.floor(this.currentLevel / 30);\n\n        let mapKeys = Object.keys(mapAtlas.terrain);\n\n        if (mapIndex >= mapKeys.length) {\n            mapIndex = mapKeys.length - 1;\n        }\n\n        let floor = mapKeys[mapIndex];\n\n        let main = mapAtlas.terrain[floor].light.base.main;\n        let specks = mapAtlas.terrain[floor].light.base.specks;\n        let full = mapAtlas.terrain[floor].light.base.hole;\n\n        let patch = mapAtlas.terrain[floor].light.layer.patch;\n        let bigHole = mapAtlas.terrain[floor].light.layer.bigHole;\n        let smallSpot = mapAtlas.terrain[floor].light.layer.smallSpot;\n        // let tinySpot = mapAtlas.terrain[floor].light.layer.tinySpot;\n\n        let mapChoice = [main, specks, full];\n        let layer = [patch, bigHole, smallSpot];\n\n\n        this.level = [];\n        this.layer = [];\n\t\tif (map) {\n            let level = map.body;\n            for (let x = level.pos.x; x <= level.size.x; x++) {\n                this.level[x] = [];\n                this.layer[x] = [];\n                for (let y = level.pos.y; y <= level.size.y; y++) {\n                    this.level[x][y] = mapChoice[randomInt(0,2)]\n                    let layerChance = randomInt(0,100);\n                    if (layerChance < 3) {\n                        this.layer[x][y] = layer[layerChance];\n                    } else {\n                        this.layer[x][y] = false;\n                    }\n                }\n            }\n        }\n\t}\n}"]},"metadata":{},"sourceType":"module"}